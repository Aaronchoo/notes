\documentclass[12pt]{article}

\usepackage{fullpage,url,amssymb,epsfig,color,xspace,enumitem, amsmath, spverbatim}
\usepackage[
pdftitle={CS 240 Assignment 3},
pdfsubject={University of Waterloo, CS 240, Spring 2019},
pdfauthor={}]
{hyperref}

\renewcommand{\thesubsection}{\arabic{subsection}}

\begin{document}
	
	Midterm Review Solutions
\begin{enumerate}
\subsection{ Binary Data }

	\item Convert −233 into 14-bit binary two’s complement integer.
	\item Convert 0xCE into decimal using two’s complement and unsigned int as convention.
	
	\subsection{Assembly Language Programming}
	\item 
	\begin{enumerate}
		\item Write an assembly language procedure gcd that computes the greatest common denominator
		of two unsigned numbers, stored in Register 1 and 2. The result should be stored in register 3.
		\item Write an assembly language procedure gcdarray that computes the greatest common denominator of unsigned numbers in an array with it’s address stored in Register 1 and length in
		Register 2. The result should be stored in register 3.
	\end{enumerate}
		\item 
	\begin{enumerate}
		\item Write a MIPS procedure printHexDigit, which takes a number from 0 to 15 (In decimal) in
		Register 1 and print the corresponding hexadecimal digit (The letters are printed in upper case).
		\item Write a procedure printHex, which has one parameter being a unsigned 32-bit integer. The
		procedure should print the integer in 8 hexadecimal digits, preceded by 0x, and followed by a
		newline character.
		You may assume that printHexDigit procedure has been defined.
	\end{enumerate}
    ASCII values of selected characters, for your convenience: ’0’ == 48, ’A’ == 65, ’x’ == 120,
    ’\\n’ == 10.
    \item Write a procedure bincoeff compute and store the value of     $\binom{n}{k}$
    in register 3, with n stored in register
    1 and k stored in register 2. Use recursion. You don’t have to worry about overflow.
    
    Recall:
    $\binom{n}{k} = \binom{n−1}{k−1} + \binom{n−1}{k} $ and $\binom{n}{0} = \binom{n}{n} = 1$
    
    \subsection{Assembling Instructions}
    \item An assembly file has been deleted accidentally, and only a fragment of the assembled machine code
    is recovered. The xxd output of the fragment is shown below.
    \begin{spverbatim}
    \$ xxd -c4 file.mips
    00000000: 0000 0814 ....
    00000004: 0000 000c ....
    00000008: 0000 1014 ....
    0000000c: afc1 fffc ....
    00000010: 0022 0018 ."..
    00000014: 0000 1812 ....
    00000018: 8fc1 fffc ....
    0000001c: 1420 fff8 . ..
    00000020: 03e0 0008 ....
    \end{spverbatim}
\begin{enumerate}
	\item Recover the assembly code. You may use labels if appropriate.
	\item what is the value of register 1 when the this piece of code have finished execution? Assume that
	the memory values around the stack pointer (\$30) is initially at 0.
\end{enumerate}
\subsection{Formal Languages}
\item Determine if the following statements are true or false.
\begin{enumerate}
	\item Every finite language is a regular language.
	\item Every regular language is a context-free language.
	\item Every context free language is a regular language.
	\item The union of two regualr languages is also regular.
	\item The intersection of two regular languages is also regular.
	\item The concatenation od teo regular languages is also regular.
	\item The union of two context-free languages is also context-free.
	\item The concatenation of two context-free languages is also context-free.
	\item Every language is either regular or context-free.
\end{enumerate}
\item Draw a DFA for the language over {0, 1} that contains at least 2 0s and no 111 as a substring.
\item Draw an NFA for the language over {0, 1, 2, 3} that contains all string that start with 212 or end with 03.
\item Write a regualr expression for the language over {0, 1} that does not contain 101.
\item \begin{enumerate}
	\item write a context-free grammar for the language $L= {0^n1^m:n \le m \le 3n} $
	\item Can you write a DFA for this language? If yes, draw such a DFA. If no, try and explain why.
	\item * Write a context-free grammarr for the language L  that contains all strings over {(,)} that contains all strings that has atleast one unbalanced parenthesis.
\end{enumerate}
\item Show that the following grammar is ambiguous using parse trees:
$ S \rightarrow AB$

$ A \rightarrow AB $

$ B \rightarrow BB $

$ B \rightarrow BA $

$ A \rightarrow x $

$ B \rightarrow y $
\subsection{Parsing}
\item The following C code does not compile:
\begin{spverbatim}
	#include <stdlib.h>
	int main(){
		int x = 9;
		int *y = malloc(sizeof(int));
		return x/*y;
	}
\end{spverbatim}
Try and explain why this is the case from what you ave learned about tokenizing.
\item The following grammar is not LL(1). Explain why.
$ S \rightarrow E$

$ E \rightarrow T + E $

$ T \rightarrow F*T $

$ F \rightarrow a|E $

\item Consider the following grammar with start state S.
S → sABk (1)
A → ABC (2)
A → AB (3)
A → a (4)
A → ε (5)
B → CD (6)
B → b (7)
C → cC (8)
C → ε (9)
D → d (10)
D → ε (11)
\begin{enumerate}
	\item Write the First, Nullable, Follow and the predictor table for this grammar.
	\item Is this grammar LL(1)?
\end{enumerate}
\end{enumerate}

\

\end{document}
